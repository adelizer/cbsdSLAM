//MRPT headers had to be included before other headers to avoid compilation errors
#include "depthfeaturescoordinator.h"
#include "mrptcoordinator.h"

#include <ros/ros.h>
#include <stdio.h>
#include "laser_geometry/laser_geometry.h"
#include <sensor_msgs/LaserScan.h>
#include <sensor_msgs/PointCloud2.h>
#include <nav_msgs/Odometry.h>
#include <tf/transform_datatypes.h>

#include<math.h>
#include<cmath>
#include <iostream>
#include <vector>
#include <string>

using namespace std;

double unwrap(double previousAngle,double newAngle);

class ScanNode
{
    ros::NodeHandle nh_;
    ros::Subscriber scan_sub_;
    ros::Subscriber odom_sub_;
    ros::Subscriber vel_sub_;

    DepthFeaturesCoordinator dp;
    mrptCoordinator m;

    double x, y, theta;

    bool initDone;

public:
    bool kill;
    ScanNode()
    {
        scan_sub_ = nh_.subscribe<sensor_msgs::LaserScan>("/scan",1,&ScanNode::scanCallback, this);
        odom_sub_ = nh_.subscribe<nav_msgs::Odometry>("/segway_rmp_node_front/odom", 1, &ScanNode::odomCallback, this);
        vel_sub_ = nh_.subscribe<geometry_msgs::Twist>("/cmd_vel_mux/input/teleop",1,&ScanNode::velCallback, this);
        dp.config();
        m.config();

        initDone = false;
    }
    ~ScanNode(){}

    void velCallback(const geometry_msgs::Twist::ConstPtr& msg){
cout << "in vel call ";
           m.setInput(msg->linear.x * 11, 0.0, msg->angular.z*5);
cout << "finished " << endl;
      }

    void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan)
    {
        cout << "Received Scan";
        int n = scan->ranges.size();
        vector<float> ranges, angles;
        vector<char> valid;
        double currentAngle = scan->angle_min;
        double anglInc = scan->angle_increment;
        for(int i = 0; i < n; i++){
            ranges.push_back(scan->ranges[i]);
            angles.push_back(currentAngle);
            currentAngle+= anglInc;
            if(scan->ranges[i] > scan->range_max || scan->ranges[i] < scan->range_min){
                valid.push_back(0);
            }else{
                valid.push_back(1);
            }
        }

        double xS, yS, thetaS;
        m.getPose(xS, yS, thetaS);
        dp.setPose(xS, yS, thetaS);
        dp.setScan(ranges, valid);
cout << "finished " << endl;
    }

    void odomCallback(const nav_msgs::Odometry::ConstPtr& vel)
    {
cout << "in odom call ";
        double quatx, quaty, quatz, quatw;
        quatx = quaty = 0;
        quatz = vel->pose.pose.orientation.z;
        quatw = vel->pose.pose.orientation.w;


        tf::Quaternion q(quatx, quaty, quatz, quatw);
        tf::Matrix3x3 rot(q);
        double roll, pitch, yaw;
        rot.getRPY(roll, pitch, yaw);

        if(!initDone){
            x = vel->pose.pose.position.x;
            y = vel->pose.pose.position.y;
            theta = yaw;
            initDone = true;
        }

        double diffX, diffY, diffTheta, v;

        diffX = vel->pose.pose.position.x - x;
        diffY = vel->pose.pose.position.y - y;
        v = sqrt(pow(diffX, 2) + pow(diffY, 2));

        double temp = unwrap(theta, yaw);
        diffTheta = temp - theta;

        m.setInput(v*2.0, 0.0, diffTheta * 0.64);
        x = vel->pose.pose.position.x;
        y = vel->pose.pose.position.y;
        theta = temp;
cout << "finished " << endl;
    }

    void update(){
        dp.runOnce();
        m.runOnce();
        cout << "Kill sig: " << m.kill << " " << dp.kill << endl;
        kill = dp.kill || m.kill;
    }

    void printScannerInfo(const sensor_msgs::LaserScan::ConstPtr& scan){
        cout << "Angle min: " << scan->angle_min << ",  ";
        cout << "Angle increment: " << scan->angle_increment << ",  ";
        cout << "Angle Max: " << scan->angle_max << ",  ";
        cout << "Range Max: " << scan->range_max << ",  ";
        cout << "Range min: " << scan->range_min << ",  ";
        cout << "scan time: " << scan->scan_time << ",  ";
        cout << "time inc: " << scan->time_increment << endl;
    }

};



int main(int argc, char **argv)
{
    ros::init(argc, argv, "Scan_Node");
    ScanNode s;
    ros::Rate loop_rate(20);
    while (ros::ok() && !s.kill){
        s.update();
        ros::spinOnce();
        loop_rate.sleep();
    }

    cout << "Exited cleanly" << endl;

    return 0;
}


inline double constrainAngle(double x){
    x = fmod(x + M_PI,M_2PI);
    if (x < 0)
        x += M_2PI;
    return x - M_PI;
}
// convert to [-360,360]
inline double angleConv(double angle){
    return fmod(constrainAngle(angle),M_2PI);
}
inline double angleDiff(double a,double b){
    double dif = fmod(b - a + M_PI,M_2PI);
    if (dif < 0)
        dif += M_2PI;
    return dif - M_PI;
}
inline double unwrap(double previousAngle,double newAngle){
    return previousAngle - angleDiff(newAngle,angleConv(previousAngle));
}

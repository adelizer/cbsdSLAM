//MRPT headers had to be included before other headers to avoid compilation errors
#include "pfcoordinator.h"
#include "visionfeaturescoordinator.h"

#include <ros/ros.h>
#include <stdio.h>
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/Pose2D.h"
#include "sensor_msgs/LaserScan.h"
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <nav_msgs/Odometry.h>
#include "sensor_msgs/ChannelFloat32.h"
#include <tf/transform_datatypes.h>

#include<math.h>
#include<cmath>
#include <iostream>
#include <vector>
#include <string>

using namespace std;


class PFNode
{
    ros::NodeHandle nh_;
    ros::Subscriber vel_sub_;
    image_transport::ImageTransport it_;
    image_transport::Subscriber usbcam_;

    visionFeaturesCoordinator vfCoordinator;
    PFCoordinator pfCoordinator;
double velx, velz;
vector<double> x, y, z;
vector<int> ids;

public:
    bool kill;
    PFNode() : it_(nh_)
    {
         vel_sub_ = nh_.subscribe<geometry_msgs::Twist>("/cmd_vel_mux/input/teleop",1,&PFNode::velCallback, this);
        usbcam_ = it_.subscribe("/usb_cam/image_raw",1, &PFNode::usbcamCallback, this);

    }
    ~PFNode(){}

    void velCallback(const geometry_msgs::Twist::ConstPtr& msg){

           velx = msg->linear.x;
           velz =  msg->angular.z / 3.0;
      }



void usbcamCallback(const sensor_msgs::ImageConstPtr& msg){

        cv_bridge::CvImagePtr cv_ptr;
        try
        {
            cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
        }
        catch (cv_bridge::Exception& e)
        {
            ROS_ERROR("cv_bridge exception: %s", e.what());
            return;
        }

        Mat img = cv_ptr->image;
vfCoordinator.setCurrentFrame(img);
vfCoordinator.runOnce();
x.clear(); x.shrink_to_fit();
z.clear(); z.shrink_to_fit();
ids.clear(); ids.shrink_to_fit();
vfCoordinator.getDetections(x, z, ids);
//vfCoordinator.visualize();
pfCoordinator.setObservations(x,y,z,ids);
if(z.size() > 0)
	cout << z[0] << endl;


}

void update(){
        pfCoordinator.setInput(velx, 0.0 , velz);
	velx = 0; velz = 0;

	pfCoordinator.runOnce();
	kill = pfCoordinator.kill;
	
}
   

};



int main(int argc, char **argv)
{
    ros::init(argc, argv, "PF_Node");
    PFNode p;
    ros::Rate loop_rate(20);
    while (ros::ok() && !p.kill){
        p.update();
        ros::spinOnce();
        loop_rate.sleep();
    }

    cout << "Exited cleanly" << endl;

    return 0;
}

